python学习笔记5-核心类型-元组和文件及其他

一、元组介绍
元组(tuple)是无法修改的其他对象的结合.元组由简单的对象构成，元组与列表类似，不过元组不能在原处修改。通常写成圆括号中的一系列项。
1、元组的属性
*任意对象的有序集合
与字符串和列表类似，元组是一个位置有序的对象集合。与列表相同，可以嵌入任何类别的对象到其中，可以嵌套元组，列表，字典。
*通过偏移存取
同字符串，列表一样，在元组中的元素通过偏移来访问。支持所有基于偏移的操作，如果索引和分片
*属于不可变序列类型
类似于字符串，元组不可变，不支持在原处修改。与字符串和列表类似，元组有序列.
注意：元组的不可变性只使用与元组本身顶层而非其内容，元组的内部的列表，字典可以像往常那样修改。
*对象引用的数组
与列表类似，元组最好被认为是对象引用的数组。元组存储指向其他对象的存取点（引用），并且对元组进行索引操作的速度相对较快。
2、常见的元组操作
运算	解释
()	空元组
t1=(0,)	单个元组的元组（非表达式）
t2=(0,'A',1.3,4) 四个元素的元组
t2=0,'A',1.3,4 四个元素的元组
t3=(1,('A','B')) 嵌套元组
t4=(1,('A', 'B'),[4,5,6],{'name':'diege','age':18})	元组嵌套元组，列表，字典
t1[i]	索引
t1[i][j]	嵌套的索引
t1[i:j]	分片
len(t1)	长度,每一个元素算一个，不过元素是列表还是字典
len(t4)+len(t4[1])+len(t4[2])+len(t4[3])
t1+t2	合并
t2*3	重复
for x in t1: 迭代
'diege' in t2 成员关系

二、实际应用中的元组
1、元组的特殊语法，逗号和圆括号
>>> x=(40)
>>> x
40
>>> x=(40,)
>>> x
(40,)
在不引起语法冲突的情况下，python允许忽略元组的圆括号，仅当元组做为文字传递给函数调用（圆括号很重要）以及当元组在print
语句中列出（逗号很重要）的特殊情况时，圆括号才是必不可少的。
2、转换以及不可变性
除了常量语法不同外，元组的操作和字符串以及列表是一致的，值得注意的区别在于+ *以及分片操作应用于元组后将返回新的元组。
并且元组不提供字符串，列表，字典中的方法。例如像对元组进行排序，通常先得将它转换为列表才能获得使用排序方法调用的权限
将它变成一个可变的对象。
>>> T=('cc','aa','dd','bb')
>>> temp=list(T) 
>>> temp.sort()
>>> temp
['aa', 'bb', 'cc', 'dd']
>>> T=tuple(temp) 
>>> T
('aa', 'bb', 'cc', 'dd')

注意：元组的不可变性只使用与元组本身顶层而非其内容，元组的内部的列表，字典可以像往常那样修改。
>>> T=('a',[8,9],3.14)
>>> T[1]=10
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> T[1][1]=10
>>> T
('a', [8, 10], 3.14)
3、为什么有了列表还要元组？
Python的创造者，提到过把元组看作是简单的对象组合，把列表看成是随时间改变的数据结构。
最佳答案似乎是元组的不可改变性提供了某种完整性，保证了数据的完整性。
列表是定序集合的选择工具，可能需要进行修改。而元组能够处理其他固定关系的情况。

三、文件介绍
文件这个主要内置对象类型提供了一种可以存取Python程序内部文件的方法。
内置open函数会创建一个Python文件对象，可以作为计算机上的一个文件连接，在调用open之后，可以通过调用返回文件对象的方法来读写
相关外部文件。文件可以通过调用open或file来打开。open通常比file更常用，因为file几乎都是为面向对象程序设计量身打造的。
文件对象只是常见文件处理任务输出模块。多数文件方法都是执行外部文件的相关文件对象的输如输出有关，但其他文件方法可让查找文件中
新位置，刷新输出缓冲等。
1、打开文件
处理模式没没有指定则默认为'r'。代表输入打开文件。'w'代表输出生成并打开文件，'a'代表为在文件尾部追加内容而打开文件。
"+"意味着同时为输入输出打开文件（也就是说，同时对象进行读写）
>>>f1=file('python.data','w')
>>>f1=open('python.data','w')
>>> f1.write('test for pyton !\n')
>>> f1.close() 
>>> f1=open('python.data','r') 
>>> f1.read()
'test for pyton !\n'
>>> f1.readline()
''
>>> f1.readlines()
[]
常见的文件运算
操作	解释
output=open('/tmp/python.data','w') 创建输出文件，写入文件
input=open('/tmp/python.data','r') 创建输入文件，读取文件
input=open('/tmp/python.data') 创建输入文件，读取文件 r是默认值
aString=input.read()	把整个文件读进一个字符串
aString=input.read(N)	读取前面的N个字节到一个字符串
aString=input.readline(N)	读取下一行到一个字符串
aList=input.readlines()	读取下一行到一个字符串列表
output.write(aString)	写入字节字符串到文件
output.writelines(aList)	把列表内所有字符串写入到文件,列表里不能有数字，数字需要转换为字符串
output.close()	手动关闭（当文件收集完成时会关闭文件
output.flush()	把输出缓冲区刷到硬盘中，但不关闭文件。
anyfile.seek(N)	修改文件位置到偏移量N处以便进行一下操作
要打开的两个参数必须是Python的字符串，第三个是可选参数。它能够用来控制输出缓存。传入"0"意味着输出无缓存（写入方法调用即时传递给外部文件）
>>> output=open('/tmp/python.data','a',0)
>>> output.write('write son \n')
# tail /tmp/python.data

file.flush()没有刷到硬盘可能会出一下问题
http://topic.csdn.net/u/20120620/10/69378f85-4386-476c-b0ab-34a1bcd181b1.html


2、使用文件
在任何情况下，Python程序中的文本文件采用字符串形式，读取文件时会返回字符串形式的文本。现在从文本读取文件行的最佳方式是根本不要读取该文件。
文件也有个迭代器会自动地在for循环，列表解析或者其他迭代语句中对文件进行逐行读取。
注意：从文件读取的数据回到脚本是一个字符串，所以如果字符串不是需要的类型。就得将其转换成其他类型的Python对象。同样。将数据写入文件时，
Python会自动把对象转换为字符串--必须传递一个已经格式化的字符串、。
Python高级标准工具，处理一般对象存储(如pickle模块），处理文件中打包的二进制数据（如struct模块）
3、在文件中存储并解析python对象
>>> X,Y,Z=43,44,45
>>> output=open('/tmp/python.data','a',0) 
>>> output.write('%s,%s,%s'% (X,Y,Z))
>>> L=[1,2,3]
>>> D={'a':1,'b':2}
>>> output.write(str(L)+'$'+str(D)+'\n') 
>>> output.close（）
>>> f1=open('/tmp/python.data').read() 
>>> f1
"43,44,45\n[1, 2, 3]${'a': 1, 'b': 2}\n 
>>> print f1
43,44,45
[1, 2, 3]${'a': 1, 'b': 2}
print 会解释内嵌换行符
鉴于Python不会自动吧字符串转换为数字或其他类型的对象，如果需要使用索引，加法等普通对象工具，那么久必须使用转换工具
>>> f1=open('/tmp/python.data') 
>>> line=f1.readline() 
>>> line
'write son \n'
>>> line.rstrip() 
'write son
rstrip方法去掉多余的终止符，line[:-1]分片也可以，但是只有确认所有行都含有"\n”的时候才行(文件中最后一行有时候会没有）
>>> line=f1.readline()
>>> line
'43,44,45\n'
>>> parts=line.split(',')
>>> parts
['43', '44', '45\n']
>>> int(parts[1]) 
44
转换文件第三行存储列表和字典，可以运行eval这一内置函数，eval能够把字符串当做可执行的程序代码。能把任何

>>> line=f1.readline()
>>> line
"[1, 2, 3]${'a': 1, 'b': 2}\n"
>>> parts
['[1, 2, 3]', "{'a': 1, 'b': 2}\n"]
>>> parts[0]
'[1, 2, 3]'
>>> eval(parts[0]) #可以把对象解析成本身的类型
[1, 2, 3]
>>> objs=[eval(P) for P in parts]
>>> objs
[[1, 2, 3], {'a': 1, 'b': 2}]
这些解析和转换最总结果是一个普通的python对象列表，而不是字符串。
4、使用pickle存储Python原生对象 【推荐】
使用eval可以把字符串转换成对象。这是一个强大的工具，有时过于强大，执行python的任何表达式，甚至是有可能会删除计算机上所有文件的表达式。
如果想存储Python原生对象，但无法信赖文件的数据来源，使用pickle模块是最理想的选择。
写入
>>> f1=open('/tmp/python.data','w',0)
>>> D 
{'a': 1, 'b': 2}
>>> import pickle
>>> pickle.dump(D,f1)
>>> f1.close()
读取
>>> f1=open('/tmp/python.data') 
>>> E=pickle.load(f1)
>>> E
{'a': 1, 'b': 2}
pickle.dump() 两个参数一个写入的内容，一个文件
pickle.load() 一个参数 文件 一次读取一行 
>>> E=pickle.load(f1)
>>> E
[1, 2, 3]
5、其他工具
seek函数能偶复位在文件中的当前位置（下次读写应用在该位置）
flush能够强制性将缓冲输出写入磁盘（文件总会模式进行缓存）
可以在交互模式下运行dir或者helo，输入file单词。

6、关闭文件
打开文件后需要关闭

with open("hello.txt") as f:
for line in f:
print line
这种方式打开后会自动关闭

f = open("hello.txt")
try:
for line in f:
print line
finally:
f.close()

老的版本使用try不管什么情况下关闭文件的方式

四、重访类型分类
对象类型	分类	是否可变
数字	数值 不可变
字符串	序列	不可变
列表	序列	可变
字典	对应（映射） 可变
元组	序列	不可变
文件	扩展	N/A
五：对象灵活性
* 列表，字典，元组可以包含任何种类的对象。
* 列表，字典，元组可以任意嵌套
* 列表，字典可以动态扩大和缩小。
六、比较，相等性和真值
所有的Python对象都可以支持比较操作--测试相等性，相对大小等。
>>> L1=[1,('a',3)]
>>> L2=[1,('a',3)] 
>>> L1==L2,L1 is L2
(True, False)
*"=="操作符测试值的相等性。Python运行测试，递归地比较所有内嵌对象。
* "is"表达式测试对象的一致性。Python测试二者是否是同一个对象。
>>> S1='diege'
>>> S2='diege' 
>>> S1==S2,S1 is S2
(True, True）
因为python会缓存短数字和短字符串缘故。
>>> S1='a longer string' 
>>> S2='a longer string'
>>> S1==S2,S1 is S2
(True, False)
>>> L1=[1,('a',3)] 
>>> L2=[1,('a',2)] 
>>> L1<L2,L1==L2,L1>L2
(False, False, True)
一般来说，Python中不同的类型比较方法如下：
*数字通过相对大小进行比较。
*字符串按照字典顺序，一个符接一个符地进行比较 ('a'<'b' ，'abc'<'ac'第二个字符串 b小于c)
*列表和元组从左到右对每部分的内容进行比较。
*字典通过排序之后的（键，值）列表进行比较。
七、Ptyhon中真和假的含义
Python中，与大多数程序设计语言一样。，整数0代表假，整数1代表真。除此之外Python也把任意的空数据结构视为假，把任何非空数据结构视为真、
更一般地，真和假的概念是Python中每个对象的固有属性。每个对象不是真就是假。
* 数字如果非0，则为真
* 其他对象如果非空，则为真
* 特殊的对象None 总被认为是假 一般起一个空的占位作用。
Python的布尔类型bool只不过是扩展了Python中真，假的概念。这些只是整数1和0的定制版本而已。
像if这样逻辑语句中，没有必要使用布尔类型，所有对象本质上依然是真或假，即时使用其他类型。
八 ：Ptyon类型的层次
Python中所有一些都是某种类型的对象，即便是默个对象的类型。任何对象的类型都是类型为“type”的对象。
每个核心类型都有个新的内置名来支持面向对象子类的类型定制
dict,list,str,tuple,int,long,float,complex,unicode ,type,file。调用这些名称事实上是对这些对象构造函数的调用，
而不仅仅是转换函数。
isinstance函数进行类型测试也是有可能的。
>>> isinstance([1],list)
True
>>> type([1])==list
True
>>> type([1])==type([])
True
九、Pythn中的其他类型
除了狠心对象外，典型的Python的安装还有几十种其他可用的对象类型。允许作为C语言的扩展程序或是Python的类:
正则表达式对象,DBM文件，GUI组件，网络套接字等。
十、内置类型陷阱。
1、赋值生成引用，而不是拷贝
2、重复能偶增加层次深度
3、留意循环数据结构
如果遇到一个复合对象包含指向自身的引用，就称之为循环对象。无论何时Python在对象中检测到循环，都会打印成[...]
而不会陷入无限循环。
尽量不要使用循环引用。不想让对象在实际中频繁的引用自身。
4、不可变类型不可以在原处改变。
有些地方的确需要拷贝，那么可以明确要求
* 没有限制条件的分片表达式（L[:]）能够赋值序列
* 字典copy方法（D.copy())能够复制字典
* 有写内置函数（例如,List）能够生产拷贝(list(L))
* copy标准库模块能够生成完整拷贝
