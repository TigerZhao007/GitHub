# 核心类型-字符串
零：序列特性和常用方法
一个有序的字符集合，用于存储和表现基于文本的信息。
常见的字符串常量和表达式
T1=‘’ 空字符串
T2="diege's" 双引号
T3="""...""" 三重引号块
T4=r'\temp\diege' Raw字符串 抑制（取消）转义，完全打印\tmp\diege，而没有制表符
T5=u’diege' Unicode字符串
T1+T2 合并
T1*3	重复
T2[i]	索引
T2[i:j] 分片
len(T2) 求长
"a %s parrot % type 字符串格式化
for x in T2: 迭代
'ie' in T2 成员关系
函数

常用函数总结：

1、删减
T2.lstrip() 移除字符串前面空格，返回字符串
T2.rstrip() 移除字符串后面空格，返回字符串
T2.strip() 移除字符串前后面空格，返回字符串 默认空格，可以其他字符 S.strip('"')

2、切割
partition(sep),
rpartition(sep),
splitlines([keepends]),#把S按照行分割符分为一个list，keepends是一个bool值，如果为真每行后而会保留行分割符
split([sep [,maxsplit]]),#以sep为分隔符，把S分成一个list。maxsplit表示分割的次数。默认的分割符为空白字符
rsplit([sep[,maxsplit]]) #从右到左切割
备注：
partition()函数族是2.5版本新增的方法。它接受一个字符串参数，并返回一个3个元素的 tuple 对象。
如果sep没出现在母串中，返回值是 (sep, ‘’, ‘’)；
否则，返回值的第一个元素是 sep 左端的部分，第二个元素是 sep 自身，第三个元素是 sep 右端的部分。
>>> S.partition(';') 
('', ';', ' generated by /sbin/dhclient-script\nnameserver 172.16.10.171\nnameserver 8.8.8.8\nnameserver 172.16.0.2\nnameserver 178.79.131.110\nnameserver 202.96.199.133\n')
参数 maxsplit 是分切的次数，即最大的分切次数，所以返回值最多有 maxsplit+1 个元素。
s.split() 和 s.split(‘ ‘)的返回值不尽相同
>>> ' hello world!'.split()
['hello', 'world!']
>>> ' hello world!'.split(' ')
['', '', 'hello', '', '', 'world!']
>>> S.split('\n',3)
['; generated by /sbin/dhclient-script', 'nameserver 172.16.10.171', 'nameserver 8.8.8.8', 'nameserver 172.16.0.2\nnameserver 178.79.131.110\nnameserver 202.96.199.133\n']
超过最大切割个数后面的全部为一个元素
按行切割
>>> S
'; generated by /sbin/dhclient-script\nnameserver 172.16.10.171\nnameserver 8.8.8.8\nnameserver 172.16.0.2\nnameserver 178.79.131.110\nnameserver 202.96.199.133\n'
>>> S.splitlines()
['; generated by /sbin/dhclient-script', 'nameserver 172.16.10.171', 'nameserver 8.8.8.8', 'nameserver 172.16.0.2', 'nameserver 178.79.131.110', 'nameserver 202.96.199.133']

产生差异的原因在于当忽略 sep 参数或sep参数为 None 时与明确给 sep 赋予字符串值时 split() 采用两种不同的算法。
对于前者，split() 先去除字符串两端的空白符，然后以任意长度的空白符串作为界定符分切字符串
即连续的空白符串被当作单一的空白符看待；
对于后者则认为两个连续的 sep 之间存在一个空字符串。因此对于空字符串（或空白符串），它们的返回值也是不同的：
>>> ''.split()
[]
>>> ''.split(' ')
['']

3、变形
lower(),#全部小写
upper(),#全部小写
capitalize(),#首字母大写
swapcase(),#大小写交换
title()#每个单词第一个大写,其他小写
备注
因为title() 函数并不去除字符串两端的空白符也不会把连续的空白符替换为一个空格，
所以建议使用string 模块中的capwords(s)函数，它能够去除两端的空白符，再将连续的空白符用一个空格代替。
>>> ' hello world!'.title()
' Hello World!'
>>> string.capwords(' hello world!')
'Hello World!'

4、连接
join(seq)
join() 函数的高效率（相对于循环相加而言），使它成为最值得关注的字符串方法之一。
它的功用是将可迭代的字符串序列连接成一条长字符串，如：
>>> conf = {'host':'127.0.0.1',
... 'db':'spam',
... 'user':'sa',
... 'passwd':'eggs'}
>>> ';'.join("%s=%s"%(k, v) for k, v in conf.iteritems())
'passswd=eggs;db=spam;user=sa;host=127.0.0.1'
>>> S=''.join(T) #使用空字符串分割把字符列表转换为字符串

5、查找
count( sub[, start[, end]]),#计算substr在S中出现的次数 
find( sub[, start[, end]]),#返回S中出现sub的第一个字母的标号，如果S中没有sub则返回-1。start和end作用就相当于在S[start:end]中搜索 
index( substr[, start[, end]]),#与find()相同，只是在S中没有substr时，会返回一个运行时错误
rfind( sub[, start[,end]]),#返回S中最后出现的substr的第一个字母的标号，如果S中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号
rindex( sub[, start[, end]])
T2.find('ie') 字符串方法调用：搜索
find()----找到的第一个符合字符的index
rfind()-----找到最后一个符合的字符的index
备注：
find()函数族找不到时返回-1，index()函数族则抛出ValueError异常。
另，也可以用 in 和 not in 操作符来判断字符串中是否存在某个模板

6、替换
replace(old, new[,count]),#把S中的oldstar替换为newstr，count为替换次数。这是替换的通用形式，还有一些函数进行特殊字符的替换 
translate(table[,deletechars]) #使用上面的函数产后的翻译表，把S进行翻译，并把deletechars中有的字符删掉
备注：
replace()函数的 count 参数用以指定最大替换次数
translate() 的参数 table 可以由 string.maketrans(frm, to) 生成
translate() 对 unicode 对象的支持并不完备，建议不要使用

7、判定
isalnum(),#是否全是字母和数字，并至少有一个字符
isalpha(),是否全是字母，并至少有一个字符
isdigit(),是否全是数字，并至少有一个字符 ，如果是全数字返回True,否则返回False
islower(),#S中的字母是否全是小写 
isupper(),#S中的字母是否是大写 
isspace(),#是否全是空白字符，并至少有一个字符
istitle(),S是否是首字母大写的
startswith(prefix[, start[, end]]), #是否以prefix开头 
endswith(suffix[,start[, end]]),#以suffix结尾 
备注：
这些函数都比较简单，顾名知义。需要注意的是*with()函数族可以接受可选的 start, end 参数，善加利用，可以优化性能。
另，自 Py2.5 版本起，*with() 函数族的 prefix 参数可以接受 tuple 类型的实参，当实参中的某人元素能够匹配，即返回 True。

8、填充
字符串在输出时的对齐：
center(width[, fillchar]), 字符串中间对齐
ljust(width[, fillchar]), 字符串左对齐，不足部分用fillchar填充，默认的为空格
rjust(width[, fillchar]), 字符串右对齐，不足部分用fillchar填充，默认的为空格
zfill(width), 把字符串变成width长，并在右对齐，不足部分用0补足
expandtabs([tabsize])把字符串中的制表符（tab）转换为适当数量的空格。

fillchar 参数指定了用以填充的字符，默认为空格
zfill的z为zero的缩写,顾名思义,是以字符0进行填充，用于数值输出
expandtabs()的tabsize 参数默认为8。它的功能是把字符串中的制表符（tab）转换为适当数量的空格。

9、编码
encode([encoding[,errors]]),
decode([encoding[,errors]])
这是一对互逆操作的方法，用以编码和解码字符串。因为str是平台相关的，它使用的内码依赖于操作系统环境，
而unicode是平台无关的，是Python内部的字符串存储方式。
unicode可以通过编码（encode）成为特定编码的str，而str也可以通过解码（decode）成为unicode。
# 其中encoding可以有多种值，比如gb2312 gbk gb18030 bz2 zlib big5 bzse64等都支持。errors默认值为"strict"，意思是UnicodeError。
可能的值还有'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 和所有的通过


http://www.cnblogs.com/rubylouvre/archive/2011/06/19/2083855.html
http://www.cnblogs.com/lovemo1314/archive/2010/10/07/1845025.html
一、字符串常量
1、单双引号字符串是一样
Python自动在任意表达式中合并相邻的字符串常量。尽管可以在他们之间增加+操作符来明确表示这是一个合并操作。
>>> T2="Test " 'for ' "diege"
>>> T2
'Test for diege'
>>> T2="Test "+'for '+"diege" 
>>> T2
'Test for diege'
不能再字符串之间增加逗号来连接，这样会创建一个元组而不是字符串。python倾向于打印所有这些形式字符串为单引号，除非字符串内有了单引号。
不过也可以通过反斜杠转义嵌入引号
>>> T2="Test "+'for '+"diege's"
>>> T2
"Test for diege's"
>>> 'diege\'s'
"diege's"
2、用转义序列代表特殊字节
\newline 忽视（连续）
\\	反斜杠（保留\)
\'	单引号（保留')
\"	双引号（保留”)
\n 换行
\f	换页
\t 水平制表符
\v 垂直制表符
\b	倒退 前的字符没有了
\a	响铃
\r	返回 前面的字符没有了
\N{id}	Unicode数据库ID
\uhhhh	Unicode16位的十六进制值
\Uhhhh	Unicode32位的十六进制值
\xhh	十六进制值
\ooo	八进制值
\0	NULL (不是字符串结尾）
\other	不转义（保留）
3、字符串抑制转义
myfile=open('C:\new\text.data','w')
这个调用会尝试打开C:（换行）ew(制表符)ext.data的文件，而不是期待的结果。
解决办法，使用raw字符串。如果字母r(大写或者小写）出现在字符串的第一个引号前面，它会关闭转义机制。
myfile=open(r'C:\new\text.data','w')‘
另外一个办法就是把\转义
myfile=open('C:\\new\\text.data','w')‘
4、三重引号编写多行字符串块
块字符串，编写多行文本数据便捷语法。
这个形式以三重引号开始（单双引号都可以），并紧跟任意行的数的本分，并且以开头同样的三重引号结尾。嵌入这个字符串文本中的
单引号双引号也会但不是必须转义。
三重引号字符串也常用在开发过程中作为一个种黑客风格的方法去废除一些代码。
如果希望让一些代码不工作，之后再次运行代码，可以简单地在这几行前，后加入三重引号
X=10
"""
import os
print os.getcwd()
"""
Y=19
5、字符串编码更大的字符集
Unicode字符串有时称为“宽”字符串。因为每个字符串也许在内存会占用大于一个字节的空间。
Unicode字符串典型的应用于支持国际化的应用(i18)
通过在开头的引号前增加字母u(大小写都可以）编写一个Unicode字符串。
>>> T9=u'diege' #这种语法产生了一个unicode字符串对象。
>>> T9
u'diege'
>>> type(T9)
<type 'unicode'>
Python中允许表达式自由地混合Unicode字符串和一般字符串。并将混合类型的结果转为Unicode。
Unicode字符串也可以合并，索引，分片。通过re模块进行匹配，并且不能够进行实地修改。和一般字符串一样。
python同等对待一般字符串和Unicode字符串
如果需要在一般字符串和Unicode字符串中转换，可以使用内置的str和unicode函数
>>> str(u'diege')
'diege'
>>> unicode('diege')
u'diege'
unicode是用来处理多字节字符的，所以能够使用特殊的"\u","\U"转义字符串去编码大于8bit的二进制值
u'ab\x20cd'
sys模块包含了默认Unicode编码方案的获取以及设置的调用（默认往往是ASCII）
可以混合raw和Unicode字符串
二、实际应用的字符串
1、基本操作
字符串长度获取方法: 内置函数len()
>>> len('test')
4
字符串连接：+
>>> 'test'+'diege'
'testdiege'
python不允许+表达式混合字符串和数字。
字符串重复：*
>>> 'test'*3
'testtesttest'
用在分割提示
>>> print '-'*80
迭代:使用for语句在一个字符串中进行迭代
>>> for s in myname: print s 
... 
d
i
e
g
e
for 循环指派了一个变量去获取一个序列其中的的元素，并对每一个元素执行一个或多个语句。
成员关系测试:使用in表达式操作符进行成员关系测试。
>>> 'g' in myname
True
>>> 'k' in myname 
False
2、索引和分片
字符串中的字符是通过索引（通过在字符串之后的方括号中提供所需的元素的数字偏移量提取的）将获得在特定位置的一个字符的字符串。
Ptyhon偏移量是从0开始的。支持负偏移量。
索引
>>> T[0],T[-2]
('d', 'g')
分片
T[开始：结束] 包含开始的位置，不包含结束的位置
>>> T[1:3],T[1:],T[:3],T[-1],T[0:-1]
('ie', 'iege', 'die', 'e', 'dieg')
>>> T[:] 
'diege‘
简单总结：
*索引（S[i])获取特定偏移的元素。
——第一个元素偏移为0
——（S[0])获取第一个元素。
——负偏移索引意味着从最后或右边反向进行计数
——（S[-2])获取倒数第二个元素（就像S[len(s)-2]一样
*分片[S[i:j]提取对应的部分作为一个序列
——右边界不包含在内
——分片的边界默认为0和序列的长度，如果没有给出的话S[:]
——（S[1:3])获取了从偏移为1，直到但不包括偏移为3的元素
——（S[1:])获取从偏移为1到末尾之间的元素
——（S[:3])获取从偏移为0直到但不包括偏移为3的元素
——（S[:-1])获取从偏移为0直到但不包括最后一个元素之间的元素
——（S[:])获取从偏移为0到末尾之间的元素,这有效地实现了顶层S拷贝
拷贝了一个相同值，但是是不同内存区域的对象。对象字符串这样不可变的对象不是很有用，但是对于可以实地修改的对象来说很有用。
比如列表。
3、扩展分片：第三个限制值 【步进】
完整形式：X[I:J:K]:这标识索引X对象的元素，从偏移为I直到J-1，每隔K元素索引一次。第三个限制值，K，默认为1
实例
>>> S='abcdefghijk'
>>> S[1:10]
'bcdefghij'
>>> S[1:10:2]
'bdfhj
也可以使用负数作为步进。
分片表达式
>>> "hello"[::-1]
'olleh'
通过负数步进，两个边界的意义实际上进行了反转。
echo.py内容
import sys
print sys.argv[:]
import sys
print sys.argv
# python echo.py -a -b -c
['echo.py', '-a', '-b', '-c']
echo.py内容
import sys
print sys.argv[1:]
# python echo.py -a -b -c
['-a', '-b', '-c']
4、字符串转换工具
Pyhon的设计座右铭之一是拒绝猜测的诱惑
Python中不能够让数字和字符串相加，甚至即时字符串看起来像是数字也不可以。
>>> '55'+1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: cannot concatenate 'str' and 'int' objects
+可以加法运算也可以进行合并操作，这种会话选择会模棱两可。要避免这样的语法。

解决脚本文件和用户界面得到一个作为字符串出现的数字该这么办？
解决办法 使用换行工具预先处理，把字符串当做数字，或者把数字当做字符串。
数字转换为字符串的方法
>>> str(55)
'55'
>>> '55'
'55
>>> T=repr(55)
>>> type(T)
<type 'str'>
字符串转换为数字
>>> int('66') 
66
>>> D=int('66')
>>> type(D)
<type 'int'>
这些操作为重新创建对象。
>>> S='55'
>>> x=1
>>> int(S)+x
56
类似的内置函数可以把浮点数转换为字符串，或者把字符串转换为浮点数
>>> str(3.1415),float("1.5")
('3.1415', 1.5)
>>> text='1.234E-10'
>>> float(text)
1.234e-10
内置eval函数，它将会运行一个包含了python表达式代码的字符串，并能够将一个字符串转换为任意类型对象。
函数int和float只能对数字进行转换。
**字符串代码转换**
同样是转换，单个的字符也可以通过将其传给内置的ord函数转换为其对应的ASCII码--这个函数实际上返回的时这个字符在
内存中对应字符的二进制。
内置chr函数则将二进制转哈为字符。
>>> ord('t') 
116
>>> chr(116)
't'
5、修改字符串
不可变序列，不能在实地修改一个字符串（如给一个索引进行赋值）
如果需要改变一个字符串，需要利用合并，分片等工具来建立并赋值给一个新的字符串，倘若必要的话，之后将这个结果赋值给
字符串最初的变量名。
>>> S='diege'
>>> S='My name is'+ S 
>>> S
'My name isdiege'
这样的修改原来的对象没有改变，只是创建了新的字符串对象，用原来的变量名连接到新的对象而已。
>>> T='diege'
>>> S=T[:3] + 'bad'+T[:-1]
>>> S
'diebaddieg’
每一次修改字符串就是生产一个新的字符串对象。

三、字符串格式化
格式化字符串的方法：
1)、在%操作符的左侧放置一个需要进行格式化的字符串，这个字符串带有一个或者多个嵌入的转换目标，都以%开头（如%d)
2)、在%操作符右侧放置一个对象（或多个，在括号内），这些对象将会插入到左侧想让Python进行格式化字符串的（或多个）转换目标的位置上去。
>>> name='diege'
>>> "My name is:%s" % name
'My name is:diege'
>>> name='diege' 
>>> age=18
>>> "My name is:%s my age is %d" % (name,age) 
'My name is:diege my age is 18'
>>> "%d %s %d you" % (1,'diege',4)
'1 diege 4 you
>>> "%s--%s--%s" % (42,3.1415,[1,2,4]) #基于元组的
'42--3.1415--[1, 2, 4]
这个例子插入三个值，一个整数，一个浮点数，一个表对象，但是注意到所有的左侧目标都是%s,这就表示要把他们转换为字符串。
由于任何对象都可以转换为字符串（打印时所使用的），每一个与%s一同参与操作的对象类型都可以转换代码。正因如此，除非你
要做特殊的格式化，一般你只需要记得用%s这个代码来格式化表达式。
格式化总会是返回新的字符串作为结果而不是对左侧的字符串进行修改。由于字符串是不可变的，所以只能这样操作。如果需要，
可以分配一个变量名来保存结果。
1、更高级的字符串格式化
Python字符串格式化支持C语言中所有常规的printf格式的代码（但是并不像printf那样显示结果，而是返回结果）。表中的一些格式化
代码为同一类型的格式化提供了不同的选择。
代码	意义
%s	字符串（或任何对象）
%r	s,但是用repr，而不是str
%c	字符
%d	十进制(整数)
%i	整数
%u	无号（整数)
%o	八进制整数
%x	十六进制整数
%X	x,但打印大写
%e	浮点指数
%E	浮点，但打印大写
%f	浮点十进制
%g	浮点e或f
%G	浮点E或f
%%	常量%
表达式左侧的转换目标支持多种转换操作。这些操作自有一套相当严谨的语法。转换目标的通用结构看上去是这样的：
$[(name)][flags][width][.precision]code
负号 左对齐
正号 右对齐
补0
宽度
>>> x=1234
>>> res="test:...%d...%-6d...%06d" % (x,x,x)
>>> res
'test:...1234...1234 ...001234'

>>> res="test:...%d...%06d...%-06d" % (x,x,x)
>>> res
'test:...1234...001234...1234 '
%06d 右对齐 左边边空格补全
%-06d 左对齐 右边0补全 实际上没有

2、基于字典的字符串格式化
字符串的格式化同时也允许左边的转换目标来引用右边字典中的键来提取对应的值。
>>> "%(n)d %(x)s" % {"n":1,"x":'diege'} 
'1 diege'
(n) (x) 引用了右边字典中的键，并提取他们相应的值。生成类似HTML或者XML的程序往往利用这一技术。
>>> reply="""
... Greetings.
... Hello %(name)s!
... Your age is %(age)s
... """
>>> values={'name':'diege','age':18}
>>> print reply % values

Greetings.
Hello diege!
Your age is 18
这样的小技巧也常与内置函数vars联起来一同使用，这个函数返回的字典包含了所有在本函数调用时存在的变量。
>>> name='diege'
>>> age='18'
>>> vars()
{'S': 'diebaddieg', 'res': 'test:...1234... 1234... 1234', 'D': 66, '__builtins__': <module '__builtin__' (built-in)>, 'text': '1.234E-10', 'age': '18', 'myname': 'diege', '__package__': None, 's': 'e', 'values': {'age': 18, 'name': 'diege'}, 'T': 'diege', 'x': 1234, 'reply': '\nGreetings.\nHello %(name)s!\nYour age is %(age)s\n', '__name__': '__main__', '__doc__': None, 'name': 'diege'}
>>> "My name is %(name)s age is %(age)s" % vars() 
'My name is diege age is 18'

四、字符串方法
除表达式运算符外，字符串还提供了一系列的方法去实现更复杂的文本处理任务。方法就是与特定的对象相关联在一起的函数。从技术
的角度讲，他们附属于对象的属性，而这些属性不过是些可调用函数罢了。在Python中，对不同的对象类型有不同的方法。字符串方法
仅限于字符串对象。
函数也就是代码包，方法调用同时进行了两次操作（一次获取属性和一次函数调用）
属性读取
具有object.attribute格式的表达式可以理解为“读取object对象的属性attribute的值".
函数调用表达式
具有函数（参数）格式的表达式意味着”调用函数代码，传递零或者更多逗号隔开的参数对象，最后返回函数的返回值”。

将两者合并可以让我们调用一个对象方法。方法调用表达式对象，方法（参数）从左至右运行，也就是说Python首先读取对象方法，然后调用它，传递参数。
如果一个方法计算出一个结果，它将会作为整个方法调用表达式的结果被返回。

绝对多数对象都可调用的方法。而且所有对象都可以通过同样的方法调用的语法来访问。为了调用对象的方法，必须确保这个
对象是存在的。

1、字符串方法实例：修改字符串
字符串方法
>>> dir(S)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split', '_formatter_parser', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
可以通过help()函数查看方法如何使用
>>> help(S.isupper())
1)替换
替换第3,4个字符
>>> S='namediege' 
>>> S=S[:3] +'XX'+S[5:]
>>> S
'namXXiege'
仅仅替换一个子字符串的话，可以使用replace方法实现
>>> S='aabbccdd' 
>>> S=S.replace('bb','gg')
>>> S
'aaggccdd'
replace 第一个参数是原始字符串（任意长度），第二个参数替换原始字符串的字符串（任意长度）
2）查找
find方法返回在子字符串出现处的偏移（默认从前向后开始搜索）或者未找到时返回-1.
3)打散 list()
list方法
>>> S='diege'
>>> list(S)
['d', 'i', 'e', 'g', 'e']
会打散成一个列表
4）合成jion()方法
>>> S='diege'
>>> list(S)
['d', 'i', 'e', 'g', 'e']
>>> T=list(S)
>>> T
['d', 'i', 'e', 'g', 'e']
>>> T[0]='P'
>>> T[3]='G' 
>>> T
['P', 'i', 'e', 'G', 'e']
>>> S=''.join(T) #使用空字符串分割把字符列表转换为字符串
>>> S
'PieGe'
>>> Y='|'.join(T)
>>> Y
'P|i|e|G|e' #使用|分割把字符串列表转换为字符串

>>> 'X'.join(['eggs','toast','moa'])
'eggsXtoastXmo

2、字符串方法实例：文本解析
1)使用分片做文本解析
>>> line="aaa bbb ccc"
>>> cols1=line[0:3]
>>> cols2=line[8:]
>>> cols1
'aaa'
>>> cols2
'ccc。
在组数据出现在固定偏移处，因此有可能通过分片从原始字符串分出来。这一技术可以被认为是解析，只要所需的数据组键有固定的偏移。
2)split方法提取组件
当所需数据没有固定的偏移时，使用split方法提取组件.在字符串中，数据出现在任意位置，这种方法都能够工作。
>>> line='aaa bbb ccc'
>>> cols=line.split()
>>> cols
['aaa', 'bbb', 'ccc']
字符串的split方法用分割符将一个字符串分割为一个子字符串的列表。默认的分隔符为空格--这个字符串被一个或多个空格，制表符或者
换行符分成多个组，之后我们得到了一个最终子字符串的列表。
>>> names='diege,kelly,lily'
>>> names.split() 
['diege,kelly,lily']
>>> names.split(',')
['diege', 'kelly', 'lily']
3、实际应用中的其他常见的字符串方法
其他的字符串方法都有更专注的角色
清除每行末尾的空白，执行大小写转换，以及检测末尾的子字符串.
>>> line='The python is running!\n'
>>> line.rstrip() 
'The python is running!
>>> line.upper()
'THE PYTHON IS RUNNING!\n
>>> line.isalpha()
False
>>> line.endswith('ing!\n')
True
>>> line.find('ing')!=-1 
True
注意没有字符串支持模式---对于基于模式的文本处理，必须使用Python的re标准库模块。
字符串方法有时与re模块的工具比较起来，有运行速度方面的优势
4、最初的字符串模块
最初的字符串模块为string模块，其中包含的函数大约相当于目前的字符串方法集。而今应该只使用字符串方法，而不是最初的string模块
五、通常意义下的类型分类
1、同样分类的类型共享其操作集合
字符串是不可改变的序列，不能在原处改变，是位置相关排序好的集合。Python中对所有序列型数据类型-都支持序列的操作--合并，索引，
迭代。类似于序列操作，在Ptyhon中有三个类型（以及操作)的分类、
*数字
支持加法，乘法等
*序列
支持索引，分片和合并等
*映射
支持通过键的索引等。
例如对于任意序列对象X和Y：
X+Y 将会创建一个包含两个操作对象内容的新的序列对象
X*N 将会包含操作对象X内容的N份拷贝的新的序列对象
换句话说，这些操作工作起来对于任意一种序列对象都一样,包括字符串，列表，元组以及用户定义的对象类型。对象的类型将会告诉
Python去执行什么样的任务。
2、可变类型能够在原处修改
不可变的分类是需要特别注意的约束。如果一个对象是不可变的，那么就不能再原处修改它的值。替代方法，必须运行代码来创建一个新的对象来包含这个心的值。
不可变类型有某种完整性，保证这个对象不会被程序的其他部分改变。
可变的类型能偶在原处修改，可以根据需要修改原数据。

关于方法和表达式小总结：
方法是类型特定的，不具有通用性
表达式是通用的，可以用于多种类型。比如切片在支持序列的对象类型，字符串，列表，元组中通用。


#####核心编程新整理添加#####
一、字符串和操作符
1、标准类型操作符和标准内建函数
1)、标准类型操作符
>,<,>=,<=,==,!=,<>对象值得比较
注：做比较时字符串是按ASCII值的大小来比较的
is 对象身份比较
and,or,not 布尔类型 
2）标准内建函数
type(obj) 
cmp(obj1,obj2)
str(obj)和repr(obj) 或反引号运算符(``) 可以方便的以字符串的方式获取对象的
内容、类型、数值属性等信息。str()函数得到的字符串可读性好， 而repr()函数得到的字符
串通常可以用来重新获得该对象, 通常情况下 obj == eval(repr(obj)) 这个等式是成立的
isinstance(obj,type) 判断对象的类型

2、序列操作 切片 [] [:] [::]
简单总结：
*索引（S[i])获取特定偏移的元素。
——第一个元素偏移为0
——（S[0])获取第一个元素。
——负偏移索引意味着从最后或右边反向进行计数
——（S[-2])获取倒数第二个元素（就像S[len(s)-2]一样
*分片[S[i:j]提取对应的部分作为一个序列
——右边界不包含在内
——分片的边界默认为0和序列的长度，如果没有给出的话S[:]
——（S[1:3])获取了从偏移为1，直到但不包括偏移为3的元素
——（S[1:])获取从偏移为1到末尾之间的元素
——（S[:3])获取从偏移为0直到但不包括偏移为3的元素
——（S[:-1])获取从偏移为0直到但不包括最后一个元素之间的元素
——（S[:])获取从偏移为0到末尾之间的元素,这有效地实现了顶层S拷贝
拷贝了一个相同值，但是是不同内存区域的对象。对象字符串这样不可变的对象不是很有用，但是对于可以实地修改的对象来说很有用。
比如列表。
扩展分片：第三个限制值 【步进】
完整形式：X[I:J:K]:这标识索引X对象的元素，从偏移为I直到J-1，每隔K元素索引一次。第三个限制值，K，默认为1
实例
>>> S='abcdefghijk'
>>> S[1:10]
'bcdefghij'
>>> S[1:10:2]
'bdfhj
也可以使用负数作为步进。
分片表达式
>>> "hello"[::-1]
'olleh'
通过负数步进，两个边界的意义实际上进行了反转。

3、成员操作符 in ，not in
返回布尔值True 或False
可以使用string模块来判断输入字符的合法性，可见成品中的idcheck.py

4、字符串连接
+ 连接字符串 ‘name’+' '+'jin'
字符串格式化 '%s %s' % ('name','jin')
join()方法 ' '.join(('name','jin')) ' '.join(['name','jin'])

5、删除清空字符串
del aString
aString=''

二、只适用于字符串的操作符
1、格式化操作符 %
字符串格式化符号
格式化字符 转换方式
%c 转换成字符(ASCII 码值，或者长度为一的字符串)
%ra 优先用repr()函数进行字符串转换
%s 优先用str()函数进行字符串转换
%d / %i 转成有符号十进制数
%ub 转成无符号十进制数
%ob 转成无符号八进制数
%xb/%Xb (Unsigned)转成无符号十六进制数(x/X 代表转换后的十六进制字符的大
小写)
%e/%E 转成科学计数法(e/E 控制输出e/E)
%f/%F 转成浮点数(小数部分自然截断)
%g/%G %e 和%f/%E 和%F 的简写
%% 输出%
格式化操作符辅助指令
符号 作用
* 定义宽度或者小数点精度
- 用做左对齐
+ 在正数前面显示加号( + )
<sp> 在正数前面显示空格
# 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于
用的是'x'还是'X')
0 显示的数字前面填充‘0’而不是默认的空格
% '%%'输出一个单一的'%'
(var) 映射变量(字典参数)
m.n m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)

2、字符串模板: 更简单的替代品
由于新式的字符串Template 对象的引进使得string 模块又重新活了过来，Template 对象
有两个方法,substitute()和safe_substitute().前者更为严谨,在key 缺少的情况下它会报一
个KeyError 的异常出来，而后者在缺少key 时，直接原封不动的把字符串显示出
>>> from string import Template
>>> s = Template('There are ${howmany} ${lang} Quotation Symbols')
>>>
>>> print s.substitute(lang='Python', howmany=3) There are 3 Python Quotation
Symbols
>>>
>>> print s.substitute(lang='Python') Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "/usr/local/lib/python2.4/string.py", line 172, in substitute
return self.pattern.sub(convert, self.template)
File "/usr/local/lib/python2.4/string.py", line 162, in convert val =
mapping[named]
KeyError: 'howmany'
>>>
>>> print s.safe_substitute(lang='Python')
There are ${howmany} Python Quotation
Symbols

3、原始字符串操作符( r/R )
字符串抑制转义r'带特殊符号的字串'
myfile=open(r'C:\new\text.data','w')

4、Unicode 字符串操作符( u/U )
u'abc' U+0061 U+0062 U+0063
u'\u1234' U+1234
u'abc\u1234\n' U+0061 U+0062 U+0063 U+1234 U+0012

三、内建函数
1、标准内建函数
type(obj) :接受一个对象做为参数，并返回它的类型。它的返回值是一个类型对象
cmp(obj1,obj2) :用于比较两个对象obj1 和obj2， 如果obj1 小于obj2, 则返回一个负整
数，如果obj1 大于obj2 则返回一个正整数， 如果obj1 等于obj2， 则返回0。
比较是在对象之间进行的，不管是标准类型对象还是用户自定
义对象。如果是用户自定义对象， cmp()会调用该类的特殊方法__cmp__()。
str(obj)和repr(obj) 或反引号运算符(``) 可以方便的以字符串的方式获取对象的
内容、类型、数值属性等信息。str()函数得到的字符串可读性好， 而repr()函数得到的字符
串通常可以用来重新获得该对象, 通常情况下 obj == eval(repr(obj)) 这个等式是成立的
isinstance(obj,type) 判断对象的类型

2、序列类型函数
len(str) 返回字串的长度
enumerate(iter):接受一个可迭代对象作为参数，返回一个enumerate 
max(str)/min(str):max()和min()函数对其他的序列类型可能更有用,但对于string类型它们能很好地运行,返回最大或者最小的字符(按照ASCII 码值排列),
zip([it0, it1,... itN]) 返回一个列表，其第一个元素是it0,it1,...这些元素的第一个元素组成的一个元组，第二个...,类推.
reversed(seq)c 接受一个序列作为参数,返回一个以逆序访问的迭代器(PEP 322)
sorted(iter,func=None,key=None,reverse=False) 接受一个可迭代对象作为参数，返回一个有序的列表;可选参数func,key 和reverse 的含义跟list.sort()内建函数的参数含义一样.
注意：
sorted等需要在原处修改的函数无法用在字符串对象，但可以产生新的对象
sum处理的对象是数字，不能用在字符串


3、字符串类型函数
1)raw_input()函数
内建的raw_input()函数使用给定字符串提示用户输入并将这个输入返回，下面是一个使
用raw_input()的例子:
>>> user_input = raw_input("Enter your name: ")
>>> prin user_input
2)str() and unicode()
str()和unicode()函数都是工厂函数，就是说产生所对应的类型的对象.它们接受一个任
意类型的对象，然后创建该对象的可打印的或者Unicode 的字符串表示. 它们和basestring 都
可以作为参数传给isinstance()函数来判断一个对象的类型
3)chr(), unichr(), and ord()
chr()函数用一个范围在range(256)内的(就是0 到255)整数做参数,返回一个对应的字符.unichr()跟它一样，只不过返回的是Unicode 字符
ord()函数是chr()函数(对于8 位的ASCII 字符串)或unichr()函数(对于Unicode 对象)
的配对函数,它以一个字符(长度为1 的字符串)作为参数,返回对应的ASCII 数值，或者Unicode
数值，如果所给的Unicode 字符超出了你的Python 定义范围,则会引发一个TypeError 的异常

4、字符串内建函数
方法 描述
1)、删减
string.lstrip() 截掉string 左边的空格
string.rstrip() 删除string 字符串末尾(右边)的空格.
string.split(str="", num=string.count(str)) 以str 为分隔符切片string，如果num有指定值，则仅分隔num 个子字符串
string.splitlines(num=string.count('\n'))b, c 按照行分隔，返回一个包含各行作为元素
的列表，如果num 指定则仅切片num 个行.
string.capitalize() 把字符串的第一个字符大写
string.center(width) 返回一个原字符串居中,并使用空格填充至长度width 的新字符串
string.count(str, beg=0,end=len(string)) 返回str 在string 里面出现的次数，如果beg 或者end 指定则返回指定范围内str 出现的次数

string.decode(encoding='UTF-8',errors='strict') 以encoding 指定的编码格式解码string，如果出错默认报一个ValueError 的异常， 除非errors 指定的是'ignore' 或者'replace'
string.encode(encoding='UTF-8',errors='strict')a 以encoding 指定的编码格式编码string，如果出错默认报一个
ValueError 的异常，除非errors 指定的是'ignore'或者'replace'

string.startswith(obj, beg=0,end=len(string))b, e 检查字符串是否是以obj 开头，是则返回True，否则返回False。如果beg 和end 指定值，则在指定范围内string.strip([obj]) 在string 上执行lstrip()和rstrip()
string.endswith(obj, beg=0,end=len(string))b,e 检查字符串是否以obj 结束，如果beg 或者end 指定则检查指定的范围内是否以obj 结束，如果是，返回True,否则返回False.

string.expandtabs(tabsize=8)把字符串string 中的tab 符号转为空格，默认的空
格数tabsize 是8.
string.find(str, beg=0,end=len(string)) 检测str 是否包含在string 中，如果beg 和end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1

string.index(str, beg=0,end=len(string)) 跟find()方法一样，只不过如果str 不在string 中会报一个异常.

string.isalnum()a, b, c R 如果string 至少有一个字符并且所有字符都是字母或数字则返回True,否则返回False
string.isalpha()a, b, c 如果string 至少有一个字符并且所有字符都是字母则返回True,否则返回False
string.isdecimal()b, c, d 如果string 只包含十进制数字则返回True 否则返回False.
string.isdigit()b, c 如果string 只包含数字则返回True 否则返回False.
string.islower()b, c 如果string 中包含至少一个区分大小写的字符，并且所有这些(区分
大小写的)字符都是小写，则返回True，否则返回False
string.isnumeric()b, c, d 如果string 中只包含数字字符，则返回True，否则返回False
string.isspace()b, c 如果string 中只包含空格，则返回True，否则返回False.
string.istitle()b, c 如果string 是标题化的(见title())则返回True，否则返回False
string.isupper()b, c 如果string 中包含至少一个区分大小写的字符，并且所有这些(区分
大小写的)字符都是大写，则返回True，否则返回False
string.join(seq) Merges (concatenates)以string 作为分隔符，将seq 中所有的元素
(的字符串表示)合并为一个新的字符串
string.ljust(width)返回一个原字符串左对齐,并使用空格填充至长度width 的新字符串
string.lower() 转换string 中所有大写字符为小写.

string.partition(str)e 有点像find()和split()的结合体,从str 出现的第一个位置起,
把字符串string 分成一个3 元素的元组
(string_pre_str,str,string_post_str),如果string 中不包含
str 则string_pre_str == string.
string.replace(str1, str2,
num=string.count(str1))把string 中的str1 替换成str2,如果num 指定，
则替换不超过num 次.
string.rfind(str, beg=0,end=len(string))类似于find()函数，不过是从右边开始查
找.
string.rindex( str, beg=0,end=len(string)) 类似于index()，不过是从右边开始.
string.rjust(width)返回一个原字符串右对齐,并使用空格填充至长度width 的新字符串
string.rpartition(str)e 类似于partition()函数,不过是从右边开始查找.

string.swapcase() 翻转string 中的大小写
string.title()b, c 返回"标题化"的string,就是说所有单词都是以大写开始，其余
字母均为小写(见istitle())
string.translate(str, del="") 根据str 给出的表(包含256 个字符)转换string 的字符,
要过滤掉的字符放到del 参数中
string.upper() 转换string 中的小写字母为大写
string.zfill(width) 返回长度为width 的字符串，原字符串string 右对齐，前面填充
