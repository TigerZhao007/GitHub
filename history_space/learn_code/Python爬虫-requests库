先来说说爬虫的原理：爬虫本质上是模拟人浏览信息的过程，只不过他通过计算机来达到快速抓取筛选信息的目的。
所以我们想要写一个爬虫，最基本的就是要将我们需要抓取信息的网页原原本本的抓取下来。
这个时候就要用到requests库了。


# 1. requests库的基本使用
#首先我们先导入requests这个包
import requests
#我们来吧百度的index页面的html源码抓取到本地，并用r变量保存
#注意这里，网页前面的 http://一定要写出来，它并不能像真正的浏览器一样帮我们补全http协议
r = requests.get("http://www.baidu.com")
#将下载到的内容打印一下：
print(r.text)
# 2. requests库的get方法
requests.get接受一个参数（url）并返回一个HTTP response对象。

#这个方法可以接收三个参数，其中第二个默认为None 第三个可选
def get(url, params=None, **kwargs)
#作用是模拟发起GET请求
Sends a GET request.
#模拟获取页面的url链接
:param url: URL for the new :class:Request object. 
#额外参数 字典或字节流格式，可选
:param params: (optional) Dictionary or bytes to be sent in the query string for the :class:Request. 
# 十二个控制访问参数，比如可以自定义header
:param **kwargs: Optional arguments that request takes. 
# 返回一个Response对象
:return: :class:Response <Response> object 
:type: requests.Response

kwargs: 控制访问的参数，均为可选项
params : 字典或字节序列，作为参数增加到url中
data : 字典、字节序列或文件对象，作为Request的内容 json : JSON格式的数据，作为Request的内容
headers : 字典，HTTP定制头
cookies : 字典或CookieJar，Request中的cookie
auth : 元组，支持HTTP认证功能
files : 字典类型，传输文件
timeout : 设定超时时间，秒为单位
proxies : 字典类型，设定访问代理服务器，可以增加登录认证
allow_redirects : True/False，默认为True，重定向开关
stream : True/False，默认为True，获取内容立即下载开关
verify : True/False，默认为True，认证SSL证书开关
cert : 本地SSL证书路径
url: 拟更新页面的url链接
data: 字典、字节序列或文件，Request的内容
json: JSON格式的数据，Request的内容

# 3. 常用的两个控制访问参数
## 3.1. 假设我们需要在GET请求里自定义一个header头文件
import requests
hd = {'User-agent':'123'}
r = requests.get('http://www.baidu.com', headers=hd)
print(r.request.headers)

## 3.2. 假设我们要自定义一个代理池
pxs = { 'http': 'http://user:pass@10.10.10.1:1234',
        'https': 'https://10.10.10.1:4321' }
r = requests.get('http://www.baidu.com', proxies=pxs)

# 4. 详细了解Response对象
import requests
r = requests.get("http://www.baidu.com")
#HTTP请求的返回状态，比如，200表示成功，404表示失败
print (r.status_code)
#HTTP请求中的headers
print (r.headers)
#从header中猜测的响应的内容编码方式 
print (r.encoding)
#从内容中分析的编码方式（慢）
print (r.apparent_encoding)
#响应内容的二进制形式
print (r.content)

# 5. requests抓取网页的通用框架
import requests
def getHtmlText(url):
    try:
        r = requests.get(url, timeout=30)
        # 如果状态码不是200 则应发HTTOError异常
        r.raise_for_status()
        # 设置正确的编码方式
        r.encoding = r.apparent_encoding
        return r.text
    except:
        return "Something Wrong!"

# 6. 快速上手
## 6.1. 发送请求
import requests
r = requests.get('https://api.github.com/events')
r0 = requests.post('http://httpbin.org/post', data = {'key':'value'})
r1 = requests.put('http://httpbin.org/put', data = {'key':'value'})
r2 = requests.delete('http://httpbin.org/delete')
r3 = requests.head('http://httpbin.org/get')
r4 = requests.options('http://httpbin.org/get')
## 6.2. 传递 URL 参数
payload = {'key1': 'value1', 'key2':  ['value2', 'value3']}
r = requests.get("http://httpbin.org/get", params=payload)
r.url
## 6.3. 响应内容
r = requests.get('https://api.github.com/events')
r.text
r.encoding
r.content
r.raw.read(10)
#将文本流保存到文件
with open(filename, 'wb') as fd:
    for chunk in r.iter_content(chunk_size):
        fd.write(chunk)
## 6.4. 定制请求头
url = 'https://api.github.com/some/endpoint'
headers = {'user-agent': 'my-app/0.0.1'}
r = requests.get(url, headers=headers)
#所有的 header 值必须是 string、bytestring 或者 unicode。
## 6.5. 更加复杂的 POST 请求
payload = {'key1': 'value1', 'key2': 'value2'}
r = requests.post("http://httpbin.org/post", data=payload)
print(r.text)
## 6.6. 编码为 JSON 的 POST/PATCH 数据
import json
url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}
r = requests.post(url, data=json.dumps(payload))
r.text
import json
url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}
r = requests.post(url, data=json.dumps(payload))
r.text















