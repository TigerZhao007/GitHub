
# 1、一行代码实现1--100之和~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 利用sum()函数求和
sum(range(1, 101))  # 5050

# 2、如何在一个函数内部修改全局变量~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 函数内部global声明 修改全局变量
a = 5
def fn():
    global a
    a = 4
fn()
print(a)   # 4

# 3、列出5个python标准库~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# os：提供了不少与操作系统相关联的函数
# sys:   通常用于命令行参数
# re:   正则匹配
# math: 数学运算
# datetime:处理日期时间

# 4、字典如何删除键和合并两个字典~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# del和updata方法
dic = {"name": 'sdk', "age": 27}
del dic['name']                        # {'age': 27}

dic2 = {"name": 'zr'}
dic.update(dic2)                       # {'age': 27, 'name': 'zr'}

# 5、谈下python的GIL~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'''
GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，
一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），
使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。
如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。
所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。

多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，
所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大
'''

# 6、python实现列表去重的方法~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 先通过集合去重，在转列表
list1 = [11, 11, 11, 12, 12, 13, 13, 13]
a = set(list1)           # {11, 12, 13}

list2 = [x for x in a]   # {11, 12, 13}
list2 = list(a)          # {11, 12, 13}

# 7、fun(*args,**kwargs)中的*args,**kwargs什么意思？~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'''
*args和*kwargs主要用于函数定义。你可以将不定数量的参数传递给一个函数。
这里不定数量的意思是：预先不知道，函数使用者会传递多少个参数给你，所以这个场景下使用这两个关键字。
'''
# *args是用来发送一个非键值对的可变参数列表给一个函数，具体案例如下：
def demo(args_f, *args_v):
    print(args_f)
    print([x for x in args_v])

demo('a', 'b', 'c', 'd', 'e')
# a
# ['b', 'c', 'd', 'e']

# **kwargs允许你将不定长度的键值对，作为参数传递给函数，
# 如果想要在一个函数里处理带名字的参数，应该使用**kwargs;具体案例如下：
def demo(**args_v):
    print([str(k) + ':' + str(v) for k, v in args_v.items()])

demo(name='sdk', age=18)   # ['name:sdk', 'age:18']

# 8、python2和python3的range（100）的区别~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# python2返回列表，python3返回迭代器，节约内存

# 9、一句话解释什么样的语言能够用装饰器?~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 函数可以作为参数传递的语言，可以使用装饰器

# 10、python内建数据类型有哪些~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 整型--int
# 布尔型--bool
# 字符串--str
# 列表--list
# 元组--tuple
# 字典--dict

# 11、简述面向对象中__new__和__init__区别~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# __init__是初始化方法，创建对象后，就立刻被默认调用了，可接收参数，如图
class Bike:
    # __init__方法自动被调用，可以创建对象接收参数。
    def __init__(self, newWheelNum, newColor):
        self.wheelNum = newWheelNum
        self.color = newColor

    def move(self):
        print('车子跑了')

# 创建对象
Bm = Bike(2, 'green')
# 只打印__init__方法执行的结果，move方法未执行
print('车的颜色为：%s'% Bm.color)         # 车的颜色为：green
print('车轮子数量为：%s'% Bm.wheelNum)    # 车轮子数量为：2
Bm.move()                                 # 车子跑了

'''
1、__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别
2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，
可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例
3、__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，
__init__不需要返回值
4、如果__new__创建的是当前类的实例，会自动调用__init__函数，
通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；
那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。
'''

class A(object):
    def __init__(self):
        print("这是 init 的方法", self)

    def __new__(cls):
        print("这是cls的ID", id(cls))
        print("这是 init 方法", object.__new__(cls))
        return object.__new__(cls)
A()
print("这是类A的ID", id(A))

'''
这是cls的ID 1543160760408
这是 init 方法 <__main__.A object at 0x000001674CD68588>
这是 init 的方法 <__main__.A object at 0x000001674CD68588>
这是类A的ID 1543160760408
'''
# 1-4相同，说明cls和类ID一样，说明指向同一个类，也就是cls就是创建的实例类。
# 2-3相同，init方法中的self和new方法返回值地址一样，说明返回值是对象。

# 12、简述with方法打开处理文件帮我我们做了什么？~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
with open('/a.txt') as f:
    f.write("hello world")

# 等同于下面的过程：
f = open('/a.txt')
try:
    f.write("hello world")
except:
    pass
finally:
    f.close()

# 打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open写法，
# 我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件，
# with方法帮我们实现了finally中f.close,（当然还有其他自定义功能，有兴趣可以研究with方法源码）

# 13、列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]~~~~~~~~~~~~~~~
# map（）函数第一个参数是fun，第二个参数是一般是list，第三个参数可以写list，也可以不写，根据需求
lis = [1, 2, 3, 4, 5]
def fn(x):
    return x**2

res = map(fn, lis)  # <map at 0x1674cd68cf8>
res = [x for x in res if x > 10]

# 14、python中生成随机整数、随机小数、0--1之间小数方法~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 随机整数：   random.randint(a,b),生成区间内的整数
# 随机小数：   习惯用numpy库，利用np.random.randn(5)生成5个随机小数
# 0-1随机小数：random.random(),括号中不传参
import random
import numpy as np
result = random.randint(10, 20)
res = np.random.randn(5)
ret = random.random()
print("正整数：", result)       # 正整数： 17
print("5个随机小数：", res)     # 5个随机小数： [ 0.24635834  2.40559902 -0.78507637 -0.35467583  0.16998527]
print("0-1随机小数：", ret)     # 0-1随机小数： 0.3952245611064742

# 15、避免转义给字符串加哪个字母表示原始字符串？~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# r , 表示需要原始字符串，不转义特殊字符

# 16、<div class="nam">中国</div>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的~~~~~~~~~~~~~~~~~~~~
import re
str = '<div class="nam">中国</div>'
res = re.findall(r'<div class=".*">(.*?)</div>', str)
print(res)

# 17、python中断言方法举例~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错
a = 3
assert(a > 1)
print("断言成功，程序继续向下执行。")

b = 4
assert(a > 7)
print("断言失败，程序报错")

# 18、数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句~~~~~~~~~~~~~~~~~~~~~~~
# select  distinct  name  from  student

# 19、10个Linux常用命令~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ls  pwd  cd  touch  rm  mkdir  tree  cp  mv  cat  more  grep  echo

# 20、python2和python3区别？列举5个~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'''
1、Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')
Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print 'hi'
2、python2 range(1,10)返回列表，python3中返回迭代器，节约内存
3、python2中使用ascii编码，python中使用utf-8编码
4、python2中unicode表示字符串序列，str表示字节序列; python3中str表示字符串序列，byte表示字节序列
5、python2中为正常显示中文，引入coding声明，python3中不需要
6、python2中是raw_input()函数，python3中是input()函数
'''
# 21、列出python中可变数据类型和不可变数据类型，并简述原理
# 不可变数据类型：数值型、字符串型string和元组tuple
'''
不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，
在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id
'''
a = 3
b = 3
id(a)   # 1672113280
id(b)   # 1672113280

# 可变数据类型：列表list和字典dict；
'''
允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，
变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，
相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。
'''
a = [1, 2]
b = [1, 2]
id(a)         # 1543182705544
id(b)         # 1543182709832

# 22、s = "ajldjlajfdljfddd"，去重并从小到大排序输出"adfjl"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# set去重，去重转成list,利用sort方法排序，reeverse=False是从小到大排
# list是不变数据类型，s.sort时候没有返回值，所以注释的代码写法不正确
s = "ajldjlajfdljfddd"
s = set(s)
s = list(s)
s.sort(reverse=False)
res = "".join(s)
print(res)

# 23、用lambda函数实现两个数相乘~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sum_lambda = lambda a, b : a * b
print(sum_lambda(5, 4))

# 24、字典根据键从小到大排序~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dic = {"name": "zs", "age": 18, "city": "深圳", "tel": "1362626627"}
lis = sorted(dic.items(), key=lambda i: i[0], reverse=False)
print(lis)           # [('age', 18), ('city', '深圳'), ('name', 'zs'), ('tel', '1362626627')]
dict(lis)            # {'age': 18, 'city': '深圳', 'name': 'zs', 'tel': '1362626627'}

# 25、利用collections库的Counter方法统计字符串每个单词出现的次数"kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"~~~~~~~~~~~~~
from collections import Counter
a = "kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"
res = Counter(a)
print(res)         # Counter({'l': 9, ';': 6, 'h': 6, 'f': 5, 'a': 4, 'j': 3, 'd': 3, 's': 2, 'k': 1, 'g': 1, 'b': 1})

# 26、字符串a = "not 404 found 张三 99 深圳"，每个词中间是空格，用正则过滤掉英文和数字，最终输出"张三  深圳"~~~~~~~~~~~~
import re
a = "not 404 found 张三 99 深圳"
list1 = a.split(" ")
print(list1)                            # ['not', '404', 'found', '张三', '99', '深圳']

res = re.findall('\d+|[a-zA-Z]+', a)    # 连接多个匹配方式， 匹配数字， 匹配单词
for i in res:
    if i in list1:
        list1.remove(i)

new_str = "".join(list1)
print(res)                              # ['not', '404', 'found', '99']
print(new_str)                          # 张三深圳

# 顺便贴上匹配小数的代码，虽然能匹配，但是健壮性有待进一步确认
import re
a = "not 404 found 张三 99 深圳"
list1 = a.split(" ")
print(list1)                            # ['not', '404', 'found', '张三', '99', '深圳']

res = re.findall('\d+\.?\d*|[a-zA-Z]+', a)
for i in res:
    if i in list1:
        list1.remove(i)
new_str = "".join(list1)
print(res)                              # ['not', '404', 'found', '99']
print(new_str)                          # 张三深圳

# 27、filter方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。
# 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，
# 最后将返回 True 的元素放到新列表（返回一个迭代器）
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
def fn(a):
    return a%2==1

newlist = filter(fn, a)
newlist = [i for i in newlist]
print(newlist)                   # [1, 3, 5, 7, 9]

# 28、列表推导式求列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
res = [i for i in a if i % 2 == 1]
print(res)                       # [1, 3, 5, 7, 9]

# 29、正则re.complie作用~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# re.compile是将正则表达式编译成一个对象，加快速度，并重复使用

# 30、a=（1，）b=(1)，c=("1") 分别是什么类型的数据？~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type((1))     # int
type((1,))    # tuple
type(('1'))   # str

# 31、两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# extend可以将另一个集合中的元素逐一添加到列表中，区别于append整体添加
list1 = [1, 5, 7, 9]
list2 = [2, 2, 6, 8]

list1.extend(list2)
list1.sort(reverse=False)   # [1, 2, 2, 3, 6, 7, 8, 9]

list1.append(list2)         # [1, 2, 2, 5, 6, 7, 8, 9, [2, 2, 6, 8]]

# 32、用python删除文件和用linux命令删除文件方法~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# python：     os.remove(文件名)
# linux:       rm  文件名

# 33、log日志中，我们需要用时间戳记录error,warning等的发生时间，请用datetime模块打印当前时间戳 “2018-04-01 11:38:54”~~
# 顺便把星期的代码也贴上了
import datetime
a = str(datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')) + ' 星期：' + str(datetime.datetime.now().isoweekday())
# 这里str报错？？？？？

# 34、数据库优化查询方法~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 外键、索引、联合查询、选择特定字段等等

# 35、请列出你会的任意一种统计图（条形图、折线图等）绘制的开源库，第三方也行~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# pychart、matplotlib

# 36、写一段自定义异常代码~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 自定义异常用raise抛出异常
def fn():
    try:
        for i in range(5):
            if i > 2:
                raise Exception("数字大于2了")
    except Exception as ret:
        print(ret)

fn()     # 数字大于2了

# 37、正则表达式匹配中，（.*）和（.*?）匹配区别？~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# （.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配
# （.*?）是非贪婪匹配，会把满足正则的尽可能少匹配
s = "<a>哈哈</a><a>呵呵</a>"
import re
res1 = re.findall("<a>(.*)</a>", s)
print("贪婪匹配：", res1)                  # 贪婪匹配： ['哈哈</a><a>呵呵']

res2 = re.findall("<a>(.*?)</a>", s)
print("非贪婪匹配：", res2)                # 非贪婪匹配： ['哈哈', '呵呵']

# 38、简述Django的orm~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'''
ORM，全拼Object-Relation Mapping，意为对象-关系映射。
实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,
orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,
所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，
如果数据库迁移，只需要更换Django的数据库引擎即可
'''

# 39、[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 列表推导式的骚操作
# 运行过程：for i in a ,每个i是【1,2】，【3,4】，【5,6】，for j in i，每个j就是1,2,3,4,5,6,合并后就是结果
a = [[1, 2], [3, 4], [5, 6]]
x = [j for i in a for j in i]
print(x)                          # [1, 2, 3, 4, 5, 6]

# 还有更骚的方法，将列表转成numpy矩阵，通过numpy的flatten（）方法，代码永远是只有更骚，没有最骚
import numpy as np
b = np.array(a).flatten().tolist()
print(b)                          # [1, 2, 3, 4, 5, 6]

# 40、x="abc",y="def",z=["d","e","f"],分别求出x.join(y)和x.join(z)返回的结果~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'''
join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致，有没有突然感觉字符串的常见操作都不会玩了
顺便建议大家学下os.path.join()方法，拼接路径经常用到，也用到了join,和字符串操作中的join有什么区别，
该问题大家可以查阅相关文档，后期会有答案
'''
x = "abc"
y = "def"
z = ["d", "e", "f"]

m = x.join(y)       # 'dabceabcf'
n = x.join(z)       # 'dabceabcf'

# 41、举例说明异常模块中try except else finally的相关意义~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# try..except..else没有捕获到异常，执行else语句
# try..except..finally不管是否捕获到异常，都执行finally语句
try:
    num = 100
    print(num)
except NameError as errorMsg:
    print('产生错误了：%s' %errorMsg)
else:
    print('没有铺获到异常，则只需该语句')

# 100
# 没有铺获到异常，则只需该语句

try:
    num = 100
    print(num)
except NameError as errorMsg:
    print('产生错误了：%s' %errorMsg)
finally:
    print('不管是否铺获到异常，都执行该句')

# 100
# 不管是否铺获到异常，都执行该句

